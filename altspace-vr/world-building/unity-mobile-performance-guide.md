---
title: AltspaceVR Mobile 性能指南
description: 了解如何使用各种 Unity 属性，使你的世界在移动设备上实现高性能（如 Oculus）
ms.date: 04/20/2021
ms.topic: article
keywords: 世界编辑器，性能，oculus，请求，unity，纹理，lightmaps，统计信息，探查器，绘图调用，altspacevr，上载器
ms.openlocfilehash: d9bb02cf6c51a604b858caf36ebbc5548e4fe267
ms.sourcegitcommit: ab0ca34d20bbbcee3ce3415b17a681f8678565b7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/12/2021
ms.locfileid: "113634288"
---
# <a name="altspacevr-mobile-performance-guide"></a>AltspaceVR Mobile 性能指南

## <a name="main-points"></a>**要点：**

* Oculus 的中的 FPS 为1和2，是目标。 **72**
* **通过静态批处理减少绘图调用** 非常重要，目的是 **不超过 25 drawcalls**
* **每个对象** 要鼓励静态批处理的一项材料 (将多材料对象分割为单独的对象) 。
* 大多数情况下，环境中的 **对象** 应设置为 **"静态"** 。
* **每个场景1个 lightmap**，每个单元 1 2k 或一个4k，每个单元约25个纹素，每个对象应根据 (对象优化 lightmap 缩放) 
* **使用移动质量着色** 器 (即 "移动/漫射" 等 ) ，避免使用 Unity 标准着色器/.Pbr/反射探测器/光源探测器，因为它们的操作很大，并且探测器将添加绘图调用。
* 屏幕上的 **三角小于 100k**
* **封闭剔除** 可帮助减少屏幕多边形，不过，使用 "诊断" 面板时，有一个提前的成本来启用封闭的精选，以便使用诊断面板度量对 Altspace 中的帧速率的影响。
* 对于场景中的所有 **纹理** ，使用 **"适用于 Android 的替代"** ，并将其设置为 **RGB () 压缩的 ASTC 6x6 块格式**。  使 Android Build 设置压缩 (在： File/Build 设置/Android/Texture 压缩： "不重写" ) ，使 Lightmaps 不会获得 ASTC 压缩。  通过执行上述操作，并通过跨对象共享材料，我们尝试将场景的 unity 包保留为约 **10-20 MB，适用于 Android**。

一般目标是在设备上跨设备获得可接受的帧数–在 Oculus 中，理想情况下，场景会在60-72 填充场景时从所有 vantage 点以 72 FPS 运行

使用 **设置/Support/Show 诊断面板/FPS**) 下的 AltspaceVR 应用 (中找到的任何设备，可在 AltspaceVR 中测量以帧速率。

标准 Unity 工具的一个断开，可帮助您更好地优化您的场景：

## <a name="stats-panelframe-debuggerprofiler"></a>**统计信息面板/帧调试器/探查器**

* 这些工具将成为改善场景性能的最佳朋友。  仅当 **场景在编辑器中播放** 时，才能对其进行引用，因为它们的值将不同于场景未播放时的值 (即，当场景未播放时，将不会发生自动静态批处理) 

* 状态 **面板** (在 "统计信息" 下的游戏视图中查看 ) 将显示 **已保存的批/批数、SetPass 的调用数和帧速率**。

    * 批–当前相机的透视中显示的当前绘图调用量。  环境的 **批处理少于25个** 是适合的目标。
    * 已保存的批 (仅在场景播放) 时可见–通过 **静态批处理或 GPU 实例** 化降低的数量绘制调用
    * SetPass 调用–场景中不同可见材料的数目
    * 帧速率–游戏视图中每秒的帧数 (可大致了解所发生的情况;应始终使用 Oculus 的帧式面板在应用内的耳机中测试场景，因为 fps 读数始终不同于编辑器内) 

*  (在 "窗口/分析/帧调试器") 下找到 **帧调试器**。  Steroids 上的 "统计信息" 面板，在启用后，将允许你查看 GPU 为创建最终图像而绘制的内容，并显示从第一个到最后一个的 drawcalls 列表。  它将为您提供一些原因，原因在于，绘图调用未使用上一次绘图调用进行批处理 (即，"此对象使用不同的材料" 或 "此对象使用不同的 Lightmap" ) ，这是一个很好的方法，用于开发了解场景中发生的情况，以及如何以及为什么某些视觉对象选项的计算成本很高。

* **探查器** 将显示运行游戏时任意时间点正在使用计算机的哪些部分。 有助于确定性能 bottlenecking 的位置。  例如，如果您在场景中看到的 CPU 使用率很高，这可能是由于绘图调用太多，或者如果看到大量的 GPU 使用情况， (也可能会发生太多的过度绘制，即，为生成最终图像而渲染单个像素的次数) 这可能是由于有多个透明的图面或对象不是在视图外剔除的。

## <a name="draw-calls-shadersmaterialsobjects"></a>**(着色器/材料/对象绘图调用)**

* 每次需要呈现着色器、材料或对象时，CPU 必须指示交换机的 GPU (也称为 "绘图调用"，俗称 **"drawcalls"**) 。  也就是说，如果有5个着色器、10个材料和20个对象（以最大为准），大约有20个 drawcalls。  其他可乘以 drawcalls 的内容包括：对象在不同的 lightmaps 上，或在场景中有多个实时光线 (即，一个点光将向其范围) 内的每个对象添加另一个 drawcall，因此，通常应避免使用场景方向光线以外的任何内容。  反射探测和光源探测器还会将绘图调用与它们命中的任何对象相乘，因此应避免发生这种情况。

* 发送到 GPU 时，**静态批处理** 将在发送到 GPU)  (的情况下，将共享相似材料的对象分批转换为一个对象。因此，通过将上面示例中的所有对象都设置为 "静态"，可将场景减小到约 10 drawcalls，1表示每个材料。 

* 当对象具有与另一个对象相同的材料时，会发生 **材料批**，但是，如果对象具有多个材料，则它不会使用具有较少材料的对象进行批处理。  因此： **对象必须只有1个材料**，并且使用多个材料的对象应拆分为每个材料的单独对象。  可以通过 **纹理 (Atlasing** 将多个唯一对象的纹理合并为共享单个纹理单，使其全部使用同一材料) ，从而减少 **材料批**。  如果可能，请尽量将地图集量保持为单2k 或4k 纹理/材料。

## <a name="scene-complexity"></a>**场景复杂性**

* **Geometry** –尝试保留10万以下环境的屏幕三角形。  使用 Unity 的游戏面板中的 "统计信息" 选项卡来查看要从场景中的各种 vantage 点命中的三角形计数。  此类属性应位于 "数百" 个三角形范围内，在数千个三角形范围内只包含重要的 "英雄" 属性。 

* 在技术上，你可以使用 **LODs** (级别的详细信息网格) ，尽管 Unity 的默认 lightmap 解决方案不在 LODs 之间共享 lightmap 数据，因此，在此解决方法时，你可能会收到 lightmapping 项目。  或者，可以将 LOD 组组件用于简单的距离剔除，即使该对象没有较低的 LOD 网格：

![Unity 中的 LOD 组窗口](images/world-building-lod-Group.png)

* **封闭剔除** 会将呈现的对象数减少到仅呈现在相机视图锥中的对象，并且会立即可见 (即，从视图封闭像素的对象剔除) 。  封闭剔除应始终对您的场景进行融入，并且应将级别设计为支持它 (也就是说，如果你有一个较大的级别，则可以使用墙壁或大型对象来分解播放机的视线，使其无法始终看到到该级别的另一端。  尽管可能需要收缩 "最小 Occluder" 或 "最小内径" 值，但默认制作设置应该有效。  对于可以在对象或透明对象中通过破裂查看的对象，应在 "静态" 下拉菜单中关闭对象的 "Occluder" 状态，使其后面的对象不会错误地封闭像素。 

## <a name="lightmaps"></a>**Lightmaps**

* 理想情况下， **每个场景只需一个 lightmap** ， (1 到2k 或一个 4k) 的所有内容，否则不会;更少的 lightmaps 更高的分辨率比低得多 lightmaps。
* 具有多个 lightmaps 也会影响绘图调用数，因为有或没有 lightmaps 的对象将位于不同的批处理上，而其他 lightmaps 还会按不同的批处理。
* 通常， **每个单位大约25个纹素** 的 Lightmap 分辨率应足以 (在照明/场景设置) 中设置分辨率。  如果在 lightmap 中有额外的空间，则可以增大此值。
* 更改每个对象的 **Lightmap 缩放** 设置，以便为需要它的对象保存解决方法。 

* **Lightmap 缩放图表** (经验)  
    * **前台** (遍历级别地理) ：1 
    * **属性** (尤其属性小于人工) ： **2-3** (，以避免对象上出现 lightmap 项目和接缝)  
    * **Midground** 在遍历区域和/或大型对象（如建筑物) ： **0.5** ）外 (几何
    *  (Vista/远处对象的 **背景**) ： **0.02** 
    * **透明表面** (如玻璃) ： **0** (禁用了 "强制转换/接收阴影")  

另外，作为基准，以下是用于屏幕护盖效果环境的一些设置：

![Unity 中的照明窗口](images/world-building-lightmaps.png)

注意：如果使用这些设置，可以将 Lightmapper 设置为 "GPU Lightmapper"，并将 Lightmap 大小设置为 "2048"，以获得更快的预览烘焙，然后备份到 CPU，4k 用于最终的制作。

## <a name="texture-compressionfile-size"></a>**纹理压缩/文件大小**

* 对于 Android 版本，我们尝试使 Unity 包的场景大小减小到约 10-20 MB。  为此，我们通过以下方式实现此目的：跨多个对象共享通用材料，使用顶点颜色为对象着色，还可以通过设置 Android 手动替代使纹理使用 **ASTC 6x6 块压缩**，这将小于默认压缩。

* 我们不会将 Android 生成设置设置为使用 ASTC，因为 lightmaps 不能) 压缩 (大量的 blocky 项目，因此，我们必须将 lightmap 设置为在每个制作后使用 ETC，因此，可以更轻松地设置所有场景纹理的替代，而不是在每个 lightmap 后更新制作的压缩设置。

![Unity 中的纹理窗口](images/world-building-texutres.png)

* 此外，将纹理设置为使用具有2个各向异性级别的 Trilinear 筛选器模式可帮助它们保持在 glancing 角度。

有关更多性能的提示和技巧，请参阅 [改善世界性能文档](improving-performance.md)。
