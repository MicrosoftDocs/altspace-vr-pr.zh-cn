---
title: AltspaceVR Mobile 性能指南
description: 了解如何使用各种 Unity 属性，使你的世界在移动设备上实现高性能（如 Oculus）
ms.date: 04/20/2021
ms.topic: article
keywords: 世界编辑器，性能，oculus，请求，unity，纹理，lightmaps，统计信息，探查器，绘图调用，altspacevr，上载器
ms.openlocfilehash: d9bb02cf6c51a604b858caf36ebbc5548e4fe267
ms.sourcegitcommit: ab0ca34d20bbbcee3ce3415b17a681f8678565b7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/12/2021
ms.locfileid: "113634288"
---
# <a name="altspacevr-mobile-performance-guide"></a><span data-ttu-id="9c735-104">AltspaceVR Mobile 性能指南</span><span class="sxs-lookup"><span data-stu-id="9c735-104">AltspaceVR Mobile Performance Guide</span></span>

## <a name="main-points"></a><span data-ttu-id="9c735-105">**要点：**</span><span class="sxs-lookup"><span data-stu-id="9c735-105">**Main Points:**</span></span>

* <span data-ttu-id="9c735-106">Oculus 的中的 FPS 为1和2，是目标。 **72**</span><span class="sxs-lookup"><span data-stu-id="9c735-106">**72 FPS** on Oculus Quest 1 and 2, is the target.</span></span>
* <span data-ttu-id="9c735-107">**通过静态批处理减少绘图调用** 非常重要，目的是 **不超过 25 drawcalls**</span><span class="sxs-lookup"><span data-stu-id="9c735-107">**Reducing Draw Calls via Static Batching** is essential, aim for **less than 25 drawcalls**</span></span>
* <span data-ttu-id="9c735-108">**每个对象** 要鼓励静态批处理的一项材料 (将多材料对象分割为单独的对象) 。</span><span class="sxs-lookup"><span data-stu-id="9c735-108">**One material per object** to encourage Static Batching (split up multi-material objects into separate objects).</span></span>
* <span data-ttu-id="9c735-109">大多数情况下，环境中的 **对象** 应设置为 **"静态"** 。</span><span class="sxs-lookup"><span data-stu-id="9c735-109">**Objects** in an environment should be set to **‘Static’** in most cases.</span></span>
* <span data-ttu-id="9c735-110">**每个场景1个 lightmap**，每个单元 1 2k 或一个4k，每个单元约25个纹素，每个对象应根据 (对象优化 lightmap 缩放) </span><span class="sxs-lookup"><span data-stu-id="9c735-110">**One lightmap per scene**, one 2k or one 4k for the whole scene, ~25 texels per unit, lightmap scaling should be tuned per object (scaling chart below)</span></span>
* <span data-ttu-id="9c735-111">**使用移动质量着色** 器 (即 "移动/漫射" 等 ) ，避免使用 Unity 标准着色器/.Pbr/反射探测器/光源探测器，因为它们的操作很大，并且探测器将添加绘图调用。</span><span class="sxs-lookup"><span data-stu-id="9c735-111">**Use Mobile-quality shaders** (that is, ‘Mobile/Diffuse’, etc.), avoid the Unity Standard shader/PBR/Reflection Probes/Light Probes as they are heavy operations and in the case of the probes will add draw calls.</span></span>
* <span data-ttu-id="9c735-112">屏幕上的 **三角小于 100k**</span><span class="sxs-lookup"><span data-stu-id="9c735-112">**Less than 100k triangles** on-screen</span></span>
* <span data-ttu-id="9c735-113">**封闭剔除** 可帮助减少屏幕多边形，不过，使用 "诊断" 面板时，有一个提前的成本来启用封闭的精选，以便使用诊断面板度量对 Altspace 中的帧速率的影响。</span><span class="sxs-lookup"><span data-stu-id="9c735-113">**Occlusion Culling** can help reduce on-screen polygons, although there is an up-front cost to having occlusion culling enabled so measure the effect on framerate in Altspace using the Diagnostics Panel.</span></span>
* <span data-ttu-id="9c735-114">对于场景中的所有 **纹理** ，使用 **"适用于 Android 的替代"** ，并将其设置为 **RGB () 压缩的 ASTC 6x6 块格式**。</span><span class="sxs-lookup"><span data-stu-id="9c735-114">For all **textures** in a scene, use **‘Override for Android’** and set them to **RGB(A) Compressed ASTC 6x6 block format**.</span></span>  <span data-ttu-id="9c735-115">使 Android Build 设置压缩 (在： File/Build 设置/Android/Texture 压缩： "不重写" ) ，使 Lightmaps 不会获得 ASTC 压缩。</span><span class="sxs-lookup"><span data-stu-id="9c735-115">Leave your Android Build Settings compression to default (found in: File/Build Settings/Android/Texture Compression: ‘Don’t override’), so that Lightmaps don’t get ASTC compression.</span></span>  <span data-ttu-id="9c735-116">通过执行上述操作，并通过跨对象共享材料，我们尝试将场景的 unity 包保留为约 **10-20 MB，适用于 Android**。</span><span class="sxs-lookup"><span data-stu-id="9c735-116">By doing the above, and by sharing materials across objects, we try to keep our scene’s unity package to around **10-20 MB for Android**.</span></span>

<span data-ttu-id="9c735-117">一般目标是在设备上跨设备获得可接受的帧数–在 Oculus 中，理想情况下，场景会在60-72 填充场景时从所有 vantage 点以 72 FPS 运行</span><span class="sxs-lookup"><span data-stu-id="9c735-117">The general goal is to hit an acceptable framerate across devices – on Oculus Quest 1 and 2 ideally the scene will run at 72 FPS from all vantage points when the scene is populated, although a range of 60-72 FPS is often a more realistic target.</span></span>

<span data-ttu-id="9c735-118">使用 **设置/Support/Show 诊断面板/FPS**) 下的 AltspaceVR 应用 (中找到的任何设备，可在 AltspaceVR 中测量以帧速率。</span><span class="sxs-lookup"><span data-stu-id="9c735-118">Framerate can be measured within AltspaceVR on whichever device that you’re using (found in the AltspaceVR app under **Settings/Support/Show Diagnostics Panel/FPS**).</span></span>

<span data-ttu-id="9c735-119">标准 Unity 工具的一个断开，可帮助您更好地优化您的场景：</span><span class="sxs-lookup"><span data-stu-id="9c735-119">A rundown of the standard Unity tools available to help you to better-optimize your scenes:</span></span>

## <a name="stats-panelframe-debuggerprofiler"></a><span data-ttu-id="9c735-120">**统计信息面板/帧调试器/探查器**</span><span class="sxs-lookup"><span data-stu-id="9c735-120">**Stats Panel/Frame Debugger/Profiler**</span></span>

* <span data-ttu-id="9c735-121">这些工具将成为改善场景性能的最佳朋友。</span><span class="sxs-lookup"><span data-stu-id="9c735-121">These tools will be your best friends in improving your scene's performance.</span></span>  <span data-ttu-id="9c735-122">仅当 **场景在编辑器中播放** 时，才能对其进行引用，因为它们的值将不同于场景未播放时的值 (即，当场景未播放时，将不会发生自动静态批处理) </span><span class="sxs-lookup"><span data-stu-id="9c735-122">They can **only be referenced while the scene is Playing in-editor**, as their values will be different from when the scene is not playing (that is, Automatic static batching won't be happening when the scene isn't playing)</span></span>

* <span data-ttu-id="9c735-123">状态 **面板** (在 "统计信息" 下的游戏视图中查看 ) 将显示 **已保存的批/批数、SetPass 的调用数和帧速率**。</span><span class="sxs-lookup"><span data-stu-id="9c735-123">**Stats Panel** (viewable in Game View under 'Stats') will show you the amount of **Batches/Batches Saved, SetPass Calls, and Framerate**.</span></span>

    * <span data-ttu-id="9c735-124">批–当前相机的透视中显示的当前绘图调用量。</span><span class="sxs-lookup"><span data-stu-id="9c735-124">Batches – the amount of current draw calls that are visible from the current camera's perspective.</span></span>  <span data-ttu-id="9c735-125">环境的 **批处理少于25个** 是适合的目标。</span><span class="sxs-lookup"><span data-stu-id="9c735-125">**Fewer than 25 batches** for an environment is a good target to aim for.</span></span>
    * <span data-ttu-id="9c735-126">已保存的批 (仅在场景播放) 时可见–通过 **静态批处理或 GPU 实例** 化降低的数量绘制调用</span><span class="sxs-lookup"><span data-stu-id="9c735-126">Batches Saved (only visible when the scene is Playing)  – the amount draw calls that have been reduced via **Static Batching or GPU Instancing**</span></span>
    * <span data-ttu-id="9c735-127">SetPass 调用–场景中不同可见材料的数目</span><span class="sxs-lookup"><span data-stu-id="9c735-127">SetPass Calls – the number of different visible materials in a scene</span></span>
    * <span data-ttu-id="9c735-128">帧速率–游戏视图中每秒的帧数 (可大致了解所发生的情况;应始终使用 Oculus 的帧式面板在应用内的耳机中测试场景，因为 fps 读数始终不同于编辑器内) </span><span class="sxs-lookup"><span data-stu-id="9c735-128">Framerate – the amount of frames-per-second in the Game view (gives you an approximate idea of what's happening; scenes should always be tested in-app, in-headset, using the Oculus Framerate panel as the fps readout will always be different than what's in-editor)</span></span>

* <span data-ttu-id="9c735-129"> (在 "窗口/分析/帧调试器") 下找到 **帧调试器**。</span><span class="sxs-lookup"><span data-stu-id="9c735-129">**Frame Debugger** (found under Window/Analysis/Frame Debugger).</span></span>  <span data-ttu-id="9c735-130">Steroids 上的 "统计信息" 面板，在启用后，将允许你查看 GPU 为创建最终图像而绘制的内容，并显示从第一个到最后一个的 drawcalls 列表。</span><span class="sxs-lookup"><span data-stu-id="9c735-130">The Stats Panel on steroids that, when enabled, will allow you to see what the GPU is drawing to create the final image, showing you a list of drawcalls from first to last.</span></span>  <span data-ttu-id="9c735-131">它将为您提供一些原因，原因在于，绘图调用未使用上一次绘图调用进行批处理 (即，"此对象使用不同的材料" 或 "此对象使用不同的 Lightmap" ) ，这是一个很好的方法，用于开发了解场景中发生的情况，以及如何以及为什么某些视觉对象选项的计算成本很高。</span><span class="sxs-lookup"><span data-stu-id="9c735-131">It will give you reasons for why a draw call wasn't batched with a previous draw call (that is, 'This object uses a different Material' or 'This object uses a different Lightmap'), and is an excellent way towards developing an understanding both of what's happening in your scene, and how and why certain visual choices can be computationally expensive.</span></span>

* <span data-ttu-id="9c735-132">**探查器** 将显示运行游戏时任意时间点正在使用计算机的哪些部分。</span><span class="sxs-lookup"><span data-stu-id="9c735-132">**Profiler** will show you what parts of the computer are being used at any point in time while the game is running.</span></span> <span data-ttu-id="9c735-133">有助于确定性能 bottlenecking 的位置。</span><span class="sxs-lookup"><span data-stu-id="9c735-133">Helpful in determining where performance is bottlenecking.</span></span>  <span data-ttu-id="9c735-134">例如，如果您在场景中看到的 CPU 使用率很高，这可能是由于绘图调用太多，或者如果看到大量的 GPU 使用情况， (也可能会发生太多的过度绘制，即，为生成最终图像而渲染单个像素的次数) 这可能是由于有多个透明的图面或对象不是在视图外剔除的。</span><span class="sxs-lookup"><span data-stu-id="9c735-134">For instance, if you are seeing heavy CPU usage in your scene, it could be that there are too many draw calls, or if you're seeing heavy GPU usage, there might be too much overdraw happening (that is, the number of times that a single pixel is rendered to produce the final image) which can be caused by having multiple transparent surfaces, or objects not being culled when out of view.</span></span>

## <a name="draw-calls-shadersmaterialsobjects"></a><span data-ttu-id="9c735-135">**(着色器/材料/对象绘图调用)**</span><span class="sxs-lookup"><span data-stu-id="9c735-135">**Draw Calls (Shaders/Materials/Objects)**</span></span>

* <span data-ttu-id="9c735-136">每次需要呈现着色器、材料或对象时，CPU 必须指示交换机的 GPU (也称为 "绘图调用"，俗称 **"drawcalls"**) 。</span><span class="sxs-lookup"><span data-stu-id="9c735-136">Every time that a shader, material or object needs to be rendered, the CPU has to instruct the GPU of the switch (also known as 'draw calls', colloquially **'drawcalls'**).</span></span>  <span data-ttu-id="9c735-137">也就是说，如果有5个着色器、10个材料和20个对象（以最大为准），大约有20个 drawcalls。</span><span class="sxs-lookup"><span data-stu-id="9c735-137">That is, if you have 5 shaders, 10 materials, and 20 objects, with whichever is greatest; you'll have approximately 20 drawcalls.</span></span>  <span data-ttu-id="9c735-138">其他可乘以 drawcalls 的内容包括：对象在不同的 lightmaps 上，或在场景中有多个实时光线 (即，一个点光将向其范围) 内的每个对象添加另一个 drawcall，因此，通常应避免使用场景方向光线以外的任何内容。</span><span class="sxs-lookup"><span data-stu-id="9c735-138">Other things that can multiply drawcalls include having objects on different lightmaps or having more than one real-time light in a scene (that is, one point light will add another drawcall to every object that is within its range), so generally anything other than a scene's directional light should be avoided.</span></span>  <span data-ttu-id="9c735-139">反射探测和光源探测器还会将绘图调用与它们命中的任何对象相乘，因此应避免发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="9c735-139">Reflection probes and light probes will also multiply draw calls on whichever objects that they hit, so they should be avoided.</span></span>

* <span data-ttu-id="9c735-140">发送到 GPU 时，**静态批处理** 将在发送到 GPU)  (的情况下，将共享相似材料的对象分批转换为一个对象。因此，通过将上面示例中的所有对象都设置为 "静态"，可将场景减小到约 10 drawcalls，1表示每个材料。</span><span class="sxs-lookup"><span data-stu-id="9c735-140">**Static Batching** will batch objects that share like-materials into a single object when sent to the GPU (with Occlusion Culling discarding meshes that are out of view), so by setting all objects in the above example to 'Static', you would reduce the scene to approximately 10 drawcalls, 1 for every material.</span></span> 

* <span data-ttu-id="9c735-141">当对象具有与另一个对象相同的材料时，会发生 **材料批**，但是，如果对象具有多个材料，则它不会使用具有较少材料的对象进行批处理。</span><span class="sxs-lookup"><span data-stu-id="9c735-141">**Material batches** occur when an object has the exact materials as another object, however if an object has multiple materials, it won't batch with an object that has fewer materials.</span></span>  <span data-ttu-id="9c735-142">因此： **对象必须只有1个材料**，并且使用多个材料的对象应拆分为每个材料的单独对象。</span><span class="sxs-lookup"><span data-stu-id="9c735-142">For this reason: **Objects MUST only have 1 material**, and objects that use several materials should be split into separate objects per material.</span></span>  <span data-ttu-id="9c735-143">可以通过 **纹理 (Atlasing** 将多个唯一对象的纹理合并为共享单个纹理单，使其全部使用同一材料) ，从而减少 **材料批**。</span><span class="sxs-lookup"><span data-stu-id="9c735-143">**Material batches** can be reduced through **Texture Atlasing** (combining multiple unique object's textures to share a single texture sheet so that they all use the same material).</span></span>  <span data-ttu-id="9c735-144">如果可能，请尽量将地图集量保持为单2k 或4k 纹理/材料。</span><span class="sxs-lookup"><span data-stu-id="9c735-144">Try to keep the amount of Atlases down to a single 2k or 4k texture/material per scene if possible.</span></span>

## <a name="scene-complexity"></a><span data-ttu-id="9c735-145">**场景复杂性**</span><span class="sxs-lookup"><span data-stu-id="9c735-145">**Scene Complexity**</span></span>

* <span data-ttu-id="9c735-146">**Geometry** –尝试保留10万以下环境的屏幕三角形。</span><span class="sxs-lookup"><span data-stu-id="9c735-146">**Geometry** – try to keep onscreen triangles for environments below 100k.</span></span>  <span data-ttu-id="9c735-147">使用 Unity 的游戏面板中的 "统计信息" 选项卡来查看要从场景中的各种 vantage 点命中的三角形计数。</span><span class="sxs-lookup"><span data-stu-id="9c735-147">Use the ‘Stats’ tab in Unity’s Game panel to see what triangle counts you’re hitting from various vantage points in the scene.</span></span>  <span data-ttu-id="9c735-148">此类属性应位于 "数百" 个三角形范围内，在数千个三角形范围内只包含重要的 "英雄" 属性。</span><span class="sxs-lookup"><span data-stu-id="9c735-148">Props as such should be in the ‘hundreds’ of triangles range, with only important ‘hero’ props in the thousands of triangles range.</span></span> 

* <span data-ttu-id="9c735-149">在技术上，你可以使用 **LODs** (级别的详细信息网格) ，尽管 Unity 的默认 lightmap 解决方案不在 LODs 之间共享 lightmap 数据，因此，在此解决方法时，你可能会收到 lightmapping 项目。</span><span class="sxs-lookup"><span data-stu-id="9c735-149">You can technically use **LODs** (level of detail meshes), although Unity’s default lightmap solution does not share lightmap data between LODs, so you may get lightmapping artifacts when the LODs switch at this resolution.</span></span>  <span data-ttu-id="9c735-150">或者，可以将 LOD 组组件用于简单的距离剔除，即使该对象没有较低的 LOD 网格：</span><span class="sxs-lookup"><span data-stu-id="9c735-150">Alternatively, you can use the LOD Group component for simple Distance Culling, even if the object doesn’t have lower LOD meshes:</span></span>

![Unity 中的 LOD 组窗口](images/world-building-lod-Group.png)

* <span data-ttu-id="9c735-152">**封闭剔除** 会将呈现的对象数减少到仅呈现在相机视图锥中的对象，并且会立即可见 (即，从视图封闭像素的对象剔除) 。</span><span class="sxs-lookup"><span data-stu-id="9c735-152">**Occlusion Culling** reduces the number of objects that are rendered to only what is within the camera's view frustum, and that are immediately visible (that is, objects that are Occluded from view are Culled).</span></span>  <span data-ttu-id="9c735-153">封闭剔除应始终对您的场景进行融入，并且应将级别设计为支持它 (也就是说，如果你有一个较大的级别，则可以使用墙壁或大型对象来分解播放机的视线，使其无法始终看到到该级别的另一端。</span><span class="sxs-lookup"><span data-stu-id="9c735-153">Occlusion culling should almost always be baked for your scene, and levels should be designed to support it (that is, if you have a large level, walls or large objects can be used to break up the player's line-of-sight, so that they can't always see through to the opposite end of the level.</span></span>  <span data-ttu-id="9c735-154">尽管可能需要收缩 "最小 Occluder" 或 "最小内径" 值，但默认制作设置应该有效。</span><span class="sxs-lookup"><span data-stu-id="9c735-154">The default bake settings should work, although you may have to shrink the 'Smallest Occluder' or 'Smallest Hole' values.</span></span>  <span data-ttu-id="9c735-155">对于可以在对象或透明对象中通过破裂查看的对象，应在 "静态" 下拉菜单中关闭对象的 "Occluder" 状态，使其后面的对象不会错误地封闭像素。</span><span class="sxs-lookup"><span data-stu-id="9c735-155">For objects like fences where you may be able to see through cracks in the object, or transparent objects, you should turn off the object's 'Occluder' status in the 'Static' drop-down menu so that objects behind it aren't erroneously occluded.</span></span> 

## <a name="lightmaps"></a><span data-ttu-id="9c735-156">**Lightmaps**</span><span class="sxs-lookup"><span data-stu-id="9c735-156">**Lightmaps**</span></span>

* <span data-ttu-id="9c735-157">理想情况下， **每个场景只需一个 lightmap** ， (1 到2k 或一个 4k) 的所有内容，否则不会;更少的 lightmaps 更高的分辨率比低得多 lightmaps。</span><span class="sxs-lookup"><span data-stu-id="9c735-157">Ideally just **one lightmap per scene** (one 2k or one 4k for everything), if not; fewer lightmaps of higher resolutions are better than many lightmaps of lower resolutions.</span></span>
* <span data-ttu-id="9c735-158">具有多个 lightmaps 也会影响绘图调用数，因为有或没有 lightmaps 的对象将位于不同的批处理上，而其他 lightmaps 还会按不同的批处理。</span><span class="sxs-lookup"><span data-stu-id="9c735-158">Having multiple lightmaps can also affect the number of draw calls, as objects that either have or don't have lightmaps will be on different batches, and other lightmaps will also be on different batches.</span></span>
* <span data-ttu-id="9c735-159">通常， **每个单位大约25个纹素** 的 Lightmap 分辨率应足以 (在照明/场景设置) 中设置分辨率。</span><span class="sxs-lookup"><span data-stu-id="9c735-159">Generally, a Lightmap Resolution of around **25 texels per unit** should suffice (set resolution in the Lighting/Scene settings).</span></span>  <span data-ttu-id="9c735-160">如果在 lightmap 中有额外的空间，则可以增大此值。</span><span class="sxs-lookup"><span data-stu-id="9c735-160">If you have extra room in your lightmap, you can increase this value.</span></span>
* <span data-ttu-id="9c735-161">更改每个对象的 **Lightmap 缩放** 设置，以便为需要它的对象保存解决方法。</span><span class="sxs-lookup"><span data-stu-id="9c735-161">Change the **Lightmap Scaling** setting per object so that the resolution is saved for objects that need it.</span></span> 

* <span data-ttu-id="9c735-162">**Lightmap 缩放图表** (经验) </span><span class="sxs-lookup"><span data-stu-id="9c735-162">**Lightmap Scaling Chart** (rule of thumb)</span></span> 
    * <span data-ttu-id="9c735-163">**前台** (遍历级别地理) ：1</span><span class="sxs-lookup"><span data-stu-id="9c735-163">**Foreground** (Traversable level geo): 1</span></span> 
    * <span data-ttu-id="9c735-164">**属性** (尤其属性小于人工) ： **2-3** (，以避免对象上出现 lightmap 项目和接缝) </span><span class="sxs-lookup"><span data-stu-id="9c735-164">**Props** (especially props smaller than a human): **2-3** (to avoid lightmap artifacts and seams on your objects)</span></span> 
    * <span data-ttu-id="9c735-165">**Midground** 在遍历区域和/或大型对象（如建筑物) ： **0.5** ）外 (几何</span><span class="sxs-lookup"><span data-stu-id="9c735-165">**Midground** (Geometry that is just outside of the traversable area and/or large objects like buildings): **0.5**</span></span>
    * <span data-ttu-id="9c735-166"> (Vista/远处对象的 **背景**) ： **0.02**</span><span class="sxs-lookup"><span data-stu-id="9c735-166">**Background** (Vista/distant objects): **0.02**</span></span> 
    * <span data-ttu-id="9c735-167">**透明表面** (如玻璃) ： **0** (禁用了 "强制转换/接收阴影") </span><span class="sxs-lookup"><span data-stu-id="9c735-167">**Transparent Surfaces** (like glass): **0** (with 'Cast/Receive Shadows’ disabled)</span></span> 

<span data-ttu-id="9c735-168">另外，作为基准，以下是用于屏幕护盖效果环境的一些设置：</span><span class="sxs-lookup"><span data-stu-id="9c735-168">Also, as a baseline, here are some settings that were used for the Screen Door Effect environment:</span></span>

![Unity 中的照明窗口](images/world-building-lightmaps.png)

<span data-ttu-id="9c735-170">注意：如果使用这些设置，可以将 Lightmapper 设置为 "GPU Lightmapper"，并将 Lightmap 大小设置为 "2048"，以获得更快的预览烘焙，然后备份到 CPU，4k 用于最终的制作。</span><span class="sxs-lookup"><span data-stu-id="9c735-170">Note: If you are using these settings, you can set the Lightmapper to 'GPU Lightmapper' and set the Lightmap Size to '2048' for much faster preview bakes, and then back up to CPU and 4k for your final bake.</span></span>

## <a name="texture-compressionfile-size"></a><span data-ttu-id="9c735-171">**纹理压缩/文件大小**</span><span class="sxs-lookup"><span data-stu-id="9c735-171">**Texture Compression/File Size**</span></span>

* <span data-ttu-id="9c735-172">对于 Android 版本，我们尝试使 Unity 包的场景大小减小到约 10-20 MB。</span><span class="sxs-lookup"><span data-stu-id="9c735-172">For our Android build, we try to keep our Unity package scene size down to around 10-20 MB total.</span></span>  <span data-ttu-id="9c735-173">为此，我们通过以下方式实现此目的：跨多个对象共享通用材料，使用顶点颜色为对象着色，还可以通过设置 Android 手动替代使纹理使用 **ASTC 6x6 块压缩**，这将小于默认压缩。</span><span class="sxs-lookup"><span data-stu-id="9c735-173">We do this by sharing generic materials across many objects, using vertex color to tint the objects, and also by setting manual overrides for Android so that textures use **ASTC 6x6 block compression**, which will be smaller than the default compression.</span></span>

* <span data-ttu-id="9c735-174">我们不会将 Android 生成设置设置为使用 ASTC，因为 lightmaps 不能) 压缩 (大量的 blocky 项目，因此，我们必须将 lightmap 设置为在每个制作后使用 ETC，因此，可以更轻松地设置所有场景纹理的替代，而不是在每个 lightmap 后更新制作的压缩设置。</span><span class="sxs-lookup"><span data-stu-id="9c735-174">The reason that we don't set the Android build settings to use ASTC is because lightmaps do not look good with that compression (lots of blocky artifacts), and we’d have to set the lightmap to use ETC after every bake, so it is easier instead to set up the override for all scene textures once than it is to update the lightmap’s compression settings after every bake.</span></span>

![Unity 中的纹理窗口](images/world-building-texutres.png)

* <span data-ttu-id="9c735-176">此外，将纹理设置为使用具有2个各向异性级别的 Trilinear 筛选器模式可帮助它们保持在 glancing 角度。</span><span class="sxs-lookup"><span data-stu-id="9c735-176">Also, setting Textures to use Trilinear Filter Mode with a 2 Anisotropic Level can help them remain sharp at glancing angles.</span></span>

<span data-ttu-id="9c735-177">有关更多性能的提示和技巧，请参阅 [改善世界性能文档](improving-performance.md)。</span><span class="sxs-lookup"><span data-stu-id="9c735-177">More performance tips and tricks can be found in the [Improving world performance documentation](improving-performance.md).</span></span>
